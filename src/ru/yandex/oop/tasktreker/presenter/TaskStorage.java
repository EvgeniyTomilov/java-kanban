package ru.yandex.oop.tasktreker.presenter;

import ru.yandex.oop.tasktreker.model.EpicTask;
import ru.yandex.oop.tasktreker.model.SubTask;
import ru.yandex.oop.tasktreker.model.Task;

import java.util.HashMap;

public class TaskStorage {
    final HashMap<Integer, Task> tasks= new HashMap<>();
    final HashMap<Integer, SubTask> subTasks= new HashMap<>();
    final HashMap<Integer, EpicTask> epicTasks= new HashMap<>();

    /*
    Один из способов организовать такое хранение — это присвоить соответствие между идентификатором и задачей
    при помощи HashMap. Поскольку идентификатор не может повторяться (иначе он не был бы идентификатором),
    такой подход позволит быстро получать задачу.

    Чтобы получать разные типы задач, вы можете создать три HashMap по одной на каждый из видов задач.

    Обновление данных
    При обновлении можете считать, что на вход подаётся новый объект, который должен полностью заменить старый.
    К примеру, метод для обновления эпика может принимать эпик в качестве входных данных public void updateTask(Task task).
    Если вы храните эпики в HashMap, где ключами являются идентификаторы, то обновление — это запись нового эпика
    tasks.put(task.getId(), task)).

    Обновление статуса задачи
    Фраза «информация приходит вместе с информацией по задаче» означает, что не существует отдельного метода, который
    занимался бы только обновлением статуса задачи. Вместо этого статус задачи обновляется вместе с полным обновлением задачи.

    Обновление эпиков
    Из описания задачи видно, что эпик не управляет своим статусом самостоятельно. Это значит:
    - Пользователь не должен иметь возможности поменять статус эпика самостоятельно.
    - Когда меняется статус любой подзадачи в эпике, вам необходимо проверить, что статус эпика изменится соответствующим образом.
    При этом изменение статуса эпика может и не произойти, если в нём, к примеру, всё ещё есть незакрытые задачи.

     */
}
